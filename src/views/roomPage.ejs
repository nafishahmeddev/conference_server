<!DOCTYPE html>
<html lang="en">
<head>
  <title><%= title %></title>
  <!-- UIkit CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.7.4/dist/css/uikit.min.css" />

  <!-- UIkit JS -->
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.7.4/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.7.4/dist/js/uikit-icons.min.js"></script>
  <link rel='stylesheet' href='/stylesheets/style.css' />
</head>
<body>
<div class="uk-height-1-1 uk-width-1-1 uk-position-relative uk-background-secondary">
  <video id="bigView" class="uk-height-1-1 uk-width-1-1" style="object-fit: contain"></video>
  <div id="videos" class="uk-position-absolute uk-height-1-1  uk-position-top-right uk-padding-small">
    <div class="uk-border-rounded uk-overflow-hidden uk-margin-small-top video-thumb remote_video_1dIoVcv4uTweCKyXAAAH">
      <video id="localView"  muted="muted" autoplay="autoplay" onclick="switchVideo(this)"></video>
      <label class="local-id"></label>
    </div>
    <div class="remote-videos"></div>
  </div>

  <small class="local-id uk-position-bottom-left uk-display-block"
         style="color: black;padding: 2px 4px; background-color: rgba(255,255,255,0.5); backdrop-filter: blur(5px); border-radius: 0 5px 0 0"></small>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.2.0/socket.io.js" integrity="sha512-WL6WGKMPBiM9PnHRYIn5YEtq0Z8XP4fkVb4qy7PP4vhmYQErJ/dySyXuFIMDf1eEYCXCrQrMJfkNwKc9gsjTjA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
  const debug = (incoming = true, message, id="") =>{
    id = id!==""?`${incoming?"from":"to"} ${id}`: "";
    console.info(incoming?"%c ↓":"%c ↑", `color: ${incoming?"green":"red"}`,  message, id );
  }
</script>
<script>
  let signaling_query = {
    room_id: "<%= room_id %>",
    name: ""
  }
  const localView = document.getElementById("localView");

  //global scopes
  let peers = {};
  let users = {};

  let remote_streams = {};
  let local_stream = [];

  //trying to get stream
  const constraints = {audio: true, video: true};
  try {
    // Get local stream, show it in self-view, and add it to be sent.
    navigator.mediaDevices.getUserMedia(constraints).then(stream => {
      local_stream = stream;
      localView.srcObject = local_stream;
      localView.play();
      askName();
      debug(false, "join");
    });
  } catch (err) {
    console.error(err);
  }

  const init = () => {
    const signaling = io("/conference", {
      query: signaling_query
    });
    // handles JSON.stringify/parse
    signaling.emit("join");
    const configuration = {iceServers: [
        {
          'urls': 'stun:stun.l.google.com:19302'
        }
      ]};
    //adder
    let createPeerAdder = async (id) => {
      // ICE candidate configuration.
      let pc = new RTCPeerConnection(configuration);
      //sending my stream
      local_stream.getTracks().forEach((track) => pc.addTrack(track, local_stream));
      pc.onicecandidate = (ev) => {
        if (!ev || !ev.candidate) return;
        signaling.emit("candidate", {
          to: id,
          candidate: ev.candidate
        });
        debug(false, "candidate", id);
      }
      //After peer connected
      pc.onnegotiationneeded = async (ev) => {
        const offer = await pc.createOffer()
        await pc.setLocalDescription(offer);
        signaling.emit("offer", {
          to: id,
          offer: pc.localDescription
        });
        debug(false, "offer", id);
      }
      // After remote track media arrives, show it in remote video element.
      pc.ontrack = (event) => {
        addRemoteView(id, event.streams, false);
      };
      return pc;
    }
    signaling.on("join", async (event) => {
      if (!event.id || !event.name) return;
      users[event.id] = {
        name: event.name
      }
      peers[event.id] = await createPeerAdder(event.id);
      debug(true, "join", event.id);
    });
    signaling.on("candidate", async (event) => {
      let pc = peers[event.from];
      if (!pc) return;
      await pc.addIceCandidate(new RTCIceCandidate(event.candidate));
      debug(true, "candidate", event.from);
    });
    //joiner
    let createPeerJoiner = (id) => {
      // ICE candidate configuration.
      let pc = new RTCPeerConnection(configuration);
      //sending my stream
      local_stream.getTracks().forEach((track) => pc.addTrack(track, local_stream));
      // Let the "negotiationneeded" event trigger offer generation.

      pc.onicecandidate = (ev) => {
        if (!ev || !ev.candidate) return;
        signaling.emit("candidate", {
          to: id,
          candidate: ev.candidate
        });
        debug(false, "candidate", id);
      }
      pc.ontrack = (event) => {
        // Don't set srcObject again if it is already set.
        addRemoteView(id, event.streams, true);
      };

      return pc;
    }
    signaling.on("offer", async (event) => {
      if (!event.from || !event.name) return;
      users[event.from] = {
        name: event.name
      };
      debug(true, "offer", event.from);
      let pc = createPeerJoiner(event.from);
      await pc.setRemoteDescription(new RTCSessionDescription(event.offer));
      await pc.setLocalDescription(await pc.createAnswer());
      signaling.emit("answer", {
        to: event.from,
        answer: pc.localDescription
      });
      debug(false, "answer", event.from);

      peers[event.from] = pc;
    });
    signaling.on("answer", async (event) => {
      if (!event.from) return;
      let pc = peers[event.from];
      await pc.setRemoteDescription(new RTCSessionDescription(event.answer));
      debug(true, "answer", event.from);
    });

    signaling.on("detached", async (id) => {
      peers[id].close();
      delete peers[id];
      delete users[id];
      deleteContainer(id);
      debug(true, "detached", id);
    });
    signaling.on("connect", e => {
      document.querySelectorAll(".local-id").forEach(label => label.innerText = signaling_query.name);
    })
    /////

  }
  const addRemoteView = (id, streams) => {
    deleteContainer(id);
    if (!streams || !id) return;
    let video = document.createElement("video");
    video.srcObject = streams[0];
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    video.onclick = (ev) => switchVideo(ev.target);


    let label = document.createElement("label");
    label.innerText = users[id]["name"];


    let content = document.createElement("div");
    content.classList.add("uk-border-rounded");
    content.classList.add("uk-overflow-hidden")
    content.classList.add("uk-margin-small-top");
    content.classList.add("video-thumb");
    content.classList.add(`remote_video_${id}`);

    content.append(video);
    content.append(label);

    let container = document.querySelector(".remote-videos");
    container.append(content);

    switchVideo(video);
  }
  const switchVideo = (el) => {
    let video = document.querySelector("#bigView");
    video.srcObject = el.srcObject;
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
  }
  const deleteContainer = (id) => {
    let videos = document.querySelectorAll(`.remote_video_${id}`);
    videos.forEach(video => video.remove());
  }

  const askName = () =>{
    UIkit.modal.prompt('Enter your name', '').then(function (name) {
      if(name){
        signaling_query.name = name;
        init();
      } else {
        askName();
      }
    });
  }





</script>
</body>
</html>


